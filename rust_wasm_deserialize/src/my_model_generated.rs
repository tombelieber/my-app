// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mypackage {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum CustomMapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CustomMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomMap<'a> {
  type Inner = CustomMap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CustomMap<'a> {
  pub const VT_B: flatbuffers::VOffsetT = 4;
  pub const VT_D: flatbuffers::VOffsetT = 6;
  pub const VT_S: flatbuffers::VOffsetT = 8;
  pub const VT_L: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CustomMap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CustomMapArgs<'args>
  ) -> flatbuffers::WIPOffset<CustomMap<'bldr>> {
    let mut builder = CustomMapBuilder::new(_fbb);
    if let Some(x) = args.l { builder.add_l(x); }
    if let Some(x) = args.s { builder.add_s(x); }
    if let Some(x) = args.d { builder.add_d(x); }
    if let Some(x) = args.b { builder.add_b(x); }
    builder.finish()
  }


  #[inline]
  pub fn b(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::BEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::BEntry>>>>(CustomMap::VT_B, None)}
  }
  #[inline]
  pub fn d(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::DEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::DEntry>>>>(CustomMap::VT_D, None)}
  }
  #[inline]
  pub fn s(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::SEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::SEntry>>>>(CustomMap::VT_S, None)}
  }
  #[inline]
  pub fn l(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::LEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::LEntry>>>>(CustomMap::VT_L, None)}
  }
}

impl flatbuffers::Verifiable for CustomMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<custom_map_::BEntry>>>>("b", Self::VT_B, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<custom_map_::DEntry>>>>("d", Self::VT_D, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<custom_map_::SEntry>>>>("s", Self::VT_S, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<custom_map_::LEntry>>>>("l", Self::VT_L, false)?
     .finish();
    Ok(())
  }
}
pub struct CustomMapArgs<'a> {
    pub b: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::BEntry<'a>>>>>,
    pub d: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::DEntry<'a>>>>>,
    pub s: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::SEntry<'a>>>>>,
    pub l: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<custom_map_::LEntry<'a>>>>>,
}
impl<'a> Default for CustomMapArgs<'a> {
  #[inline]
  fn default() -> Self {
    CustomMapArgs {
      b: None,
      d: None,
      s: None,
      l: None,
    }
  }
}

pub struct CustomMapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CustomMapBuilder<'a, 'b> {
  #[inline]
  pub fn add_b(&mut self, b: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<custom_map_::BEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomMap::VT_B, b);
  }
  #[inline]
  pub fn add_d(&mut self, d: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<custom_map_::DEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomMap::VT_D, d);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<custom_map_::SEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomMap::VT_S, s);
  }
  #[inline]
  pub fn add_l(&mut self, l: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<custom_map_::LEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomMap::VT_L, l);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CustomMapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CustomMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CustomMap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CustomMap");
      ds.field("b", &self.b());
      ds.field("d", &self.d());
      ds.field("s", &self.s());
      ds.field("l", &self.l());
      ds.finish()
  }
}
pub enum MyModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MyModel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MyModel<'a> {
  type Inner = MyModel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MyModel<'a> {
  pub const VT_STR1: flatbuffers::VOffsetT = 4;
  pub const VT_STR2: flatbuffers::VOffsetT = 6;
  pub const VT_STR3: flatbuffers::VOffsetT = 8;
  pub const VT_STR4: flatbuffers::VOffsetT = 10;
  pub const VT_STR5: flatbuffers::VOffsetT = 12;
  pub const VT_STR6: flatbuffers::VOffsetT = 14;
  pub const VT_BOOL1: flatbuffers::VOffsetT = 16;
  pub const VT_BOOL2: flatbuffers::VOffsetT = 18;
  pub const VT_BOOL3: flatbuffers::VOffsetT = 20;
  pub const VT_BOOL4: flatbuffers::VOffsetT = 22;
  pub const VT_BOOL5: flatbuffers::VOffsetT = 24;
  pub const VT_BOOL6: flatbuffers::VOffsetT = 26;
  pub const VT_NUM1: flatbuffers::VOffsetT = 28;
  pub const VT_NUM2: flatbuffers::VOffsetT = 30;
  pub const VT_NUM3: flatbuffers::VOffsetT = 32;
  pub const VT_NUM4: flatbuffers::VOffsetT = 34;
  pub const VT_NUM5: flatbuffers::VOffsetT = 36;
  pub const VT_NUM6: flatbuffers::VOffsetT = 38;
  pub const VT_OMAP: flatbuffers::VOffsetT = 40;
  pub const VT_PMAP: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MyModel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MyModelArgs<'args>
  ) -> flatbuffers::WIPOffset<MyModel<'bldr>> {
    let mut builder = MyModelBuilder::new(_fbb);
    builder.add_num6(args.num6);
    builder.add_num5(args.num5);
    builder.add_num4(args.num4);
    builder.add_num3(args.num3);
    builder.add_num2(args.num2);
    builder.add_num1(args.num1);
    if let Some(x) = args.pMap { builder.add_pMap(x); }
    if let Some(x) = args.oMap { builder.add_oMap(x); }
    if let Some(x) = args.str6 { builder.add_str6(x); }
    if let Some(x) = args.str5 { builder.add_str5(x); }
    if let Some(x) = args.str4 { builder.add_str4(x); }
    if let Some(x) = args.str3 { builder.add_str3(x); }
    if let Some(x) = args.str2 { builder.add_str2(x); }
    if let Some(x) = args.str1 { builder.add_str1(x); }
    builder.add_bool6(args.bool6);
    builder.add_bool5(args.bool5);
    builder.add_bool4(args.bool4);
    builder.add_bool3(args.bool3);
    builder.add_bool2(args.bool2);
    builder.add_bool1(args.bool1);
    builder.finish()
  }


  #[inline]
  pub fn str1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MyModel::VT_STR1, None)}
  }
  #[inline]
  pub fn str2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MyModel::VT_STR2, None)}
  }
  #[inline]
  pub fn str3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MyModel::VT_STR3, None)}
  }
  #[inline]
  pub fn str4(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MyModel::VT_STR4, None)}
  }
  #[inline]
  pub fn str5(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MyModel::VT_STR5, None)}
  }
  #[inline]
  pub fn str6(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MyModel::VT_STR6, None)}
  }
  #[inline]
  pub fn bool1(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MyModel::VT_BOOL1, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bool2(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MyModel::VT_BOOL2, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bool3(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MyModel::VT_BOOL3, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bool4(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MyModel::VT_BOOL4, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bool5(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MyModel::VT_BOOL5, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bool6(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MyModel::VT_BOOL6, Some(false)).unwrap()}
  }
  #[inline]
  pub fn num1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MyModel::VT_NUM1, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn num2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MyModel::VT_NUM2, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn num3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MyModel::VT_NUM3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn num4(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MyModel::VT_NUM4, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn num5(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MyModel::VT_NUM5, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn num6(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MyModel::VT_NUM6, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn oMap(&self) -> Option<CustomMap<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CustomMap>>(MyModel::VT_OMAP, None)}
  }
  #[inline]
  pub fn pMap(&self) -> Option<CustomMap<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CustomMap>>(MyModel::VT_PMAP, None)}
  }
}

impl flatbuffers::Verifiable for MyModel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("str1", Self::VT_STR1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("str2", Self::VT_STR2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("str3", Self::VT_STR3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("str4", Self::VT_STR4, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("str5", Self::VT_STR5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("str6", Self::VT_STR6, false)?
     .visit_field::<bool>("bool1", Self::VT_BOOL1, false)?
     .visit_field::<bool>("bool2", Self::VT_BOOL2, false)?
     .visit_field::<bool>("bool3", Self::VT_BOOL3, false)?
     .visit_field::<bool>("bool4", Self::VT_BOOL4, false)?
     .visit_field::<bool>("bool5", Self::VT_BOOL5, false)?
     .visit_field::<bool>("bool6", Self::VT_BOOL6, false)?
     .visit_field::<f64>("num1", Self::VT_NUM1, false)?
     .visit_field::<f64>("num2", Self::VT_NUM2, false)?
     .visit_field::<f64>("num3", Self::VT_NUM3, false)?
     .visit_field::<f64>("num4", Self::VT_NUM4, false)?
     .visit_field::<f64>("num5", Self::VT_NUM5, false)?
     .visit_field::<f64>("num6", Self::VT_NUM6, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CustomMap>>("oMap", Self::VT_OMAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CustomMap>>("pMap", Self::VT_PMAP, false)?
     .finish();
    Ok(())
  }
}
pub struct MyModelArgs<'a> {
    pub str1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub str2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub str3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub str4: Option<flatbuffers::WIPOffset<&'a str>>,
    pub str5: Option<flatbuffers::WIPOffset<&'a str>>,
    pub str6: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bool1: bool,
    pub bool2: bool,
    pub bool3: bool,
    pub bool4: bool,
    pub bool5: bool,
    pub bool6: bool,
    pub num1: f64,
    pub num2: f64,
    pub num3: f64,
    pub num4: f64,
    pub num5: f64,
    pub num6: f64,
    pub oMap: Option<flatbuffers::WIPOffset<CustomMap<'a>>>,
    pub pMap: Option<flatbuffers::WIPOffset<CustomMap<'a>>>,
}
impl<'a> Default for MyModelArgs<'a> {
  #[inline]
  fn default() -> Self {
    MyModelArgs {
      str1: None,
      str2: None,
      str3: None,
      str4: None,
      str5: None,
      str6: None,
      bool1: false,
      bool2: false,
      bool3: false,
      bool4: false,
      bool5: false,
      bool6: false,
      num1: 0.0,
      num2: 0.0,
      num3: 0.0,
      num4: 0.0,
      num5: 0.0,
      num6: 0.0,
      oMap: None,
      pMap: None,
    }
  }
}

pub struct MyModelBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MyModelBuilder<'a, 'b> {
  #[inline]
  pub fn add_str1(&mut self, str1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MyModel::VT_STR1, str1);
  }
  #[inline]
  pub fn add_str2(&mut self, str2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MyModel::VT_STR2, str2);
  }
  #[inline]
  pub fn add_str3(&mut self, str3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MyModel::VT_STR3, str3);
  }
  #[inline]
  pub fn add_str4(&mut self, str4: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MyModel::VT_STR4, str4);
  }
  #[inline]
  pub fn add_str5(&mut self, str5: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MyModel::VT_STR5, str5);
  }
  #[inline]
  pub fn add_str6(&mut self, str6: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MyModel::VT_STR6, str6);
  }
  #[inline]
  pub fn add_bool1(&mut self, bool1: bool) {
    self.fbb_.push_slot::<bool>(MyModel::VT_BOOL1, bool1, false);
  }
  #[inline]
  pub fn add_bool2(&mut self, bool2: bool) {
    self.fbb_.push_slot::<bool>(MyModel::VT_BOOL2, bool2, false);
  }
  #[inline]
  pub fn add_bool3(&mut self, bool3: bool) {
    self.fbb_.push_slot::<bool>(MyModel::VT_BOOL3, bool3, false);
  }
  #[inline]
  pub fn add_bool4(&mut self, bool4: bool) {
    self.fbb_.push_slot::<bool>(MyModel::VT_BOOL4, bool4, false);
  }
  #[inline]
  pub fn add_bool5(&mut self, bool5: bool) {
    self.fbb_.push_slot::<bool>(MyModel::VT_BOOL5, bool5, false);
  }
  #[inline]
  pub fn add_bool6(&mut self, bool6: bool) {
    self.fbb_.push_slot::<bool>(MyModel::VT_BOOL6, bool6, false);
  }
  #[inline]
  pub fn add_num1(&mut self, num1: f64) {
    self.fbb_.push_slot::<f64>(MyModel::VT_NUM1, num1, 0.0);
  }
  #[inline]
  pub fn add_num2(&mut self, num2: f64) {
    self.fbb_.push_slot::<f64>(MyModel::VT_NUM2, num2, 0.0);
  }
  #[inline]
  pub fn add_num3(&mut self, num3: f64) {
    self.fbb_.push_slot::<f64>(MyModel::VT_NUM3, num3, 0.0);
  }
  #[inline]
  pub fn add_num4(&mut self, num4: f64) {
    self.fbb_.push_slot::<f64>(MyModel::VT_NUM4, num4, 0.0);
  }
  #[inline]
  pub fn add_num5(&mut self, num5: f64) {
    self.fbb_.push_slot::<f64>(MyModel::VT_NUM5, num5, 0.0);
  }
  #[inline]
  pub fn add_num6(&mut self, num6: f64) {
    self.fbb_.push_slot::<f64>(MyModel::VT_NUM6, num6, 0.0);
  }
  #[inline]
  pub fn add_oMap(&mut self, oMap: flatbuffers::WIPOffset<CustomMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CustomMap>>(MyModel::VT_OMAP, oMap);
  }
  #[inline]
  pub fn add_pMap(&mut self, pMap: flatbuffers::WIPOffset<CustomMap<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CustomMap>>(MyModel::VT_PMAP, pMap);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MyModelBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MyModelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MyModel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MyModel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MyModel");
      ds.field("str1", &self.str1());
      ds.field("str2", &self.str2());
      ds.field("str3", &self.str3());
      ds.field("str4", &self.str4());
      ds.field("str5", &self.str5());
      ds.field("str6", &self.str6());
      ds.field("bool1", &self.bool1());
      ds.field("bool2", &self.bool2());
      ds.field("bool3", &self.bool3());
      ds.field("bool4", &self.bool4());
      ds.field("bool5", &self.bool5());
      ds.field("bool6", &self.bool6());
      ds.field("num1", &self.num1());
      ds.field("num2", &self.num2());
      ds.field("num3", &self.num3());
      ds.field("num4", &self.num4());
      ds.field("num5", &self.num5());
      ds.field("num6", &self.num6());
      ds.field("oMap", &self.oMap());
      ds.field("pMap", &self.pMap());
      ds.finish()
  }
}
#[allow(unused_imports, dead_code)]
pub mod custom_map_ {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum BEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BEntry<'a> {
  type Inner = BEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BEntry<'bldr>> {
    let mut builder = BEntryBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &BEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BEntry::VT_VALUE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<bool>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: bool,
}
impl<'a> Default for BEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BEntryArgs {
      key: None, // required field
      value: false,
    }
  }
}

pub struct BEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: bool) {
    self.fbb_.push_slot::<bool>(BEntry::VT_VALUE, value, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DEntry<'a> {
  type Inner = DEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DEntry<'bldr>> {
    let mut builder = DEntryBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DEntry::VT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<f64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f64,
}
impl<'a> Default for DEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DEntryArgs {
      key: None, // required field
      value: 0.0,
    }
  }
}

pub struct DEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(DEntry::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum SEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SEntry<'a> {
  type Inner = SEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<SEntry<'bldr>> {
    let mut builder = SEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &SEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for SEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct SEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    SEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct SEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum LEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LEntry<'a> {
  type Inner = LEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<LEntry<'bldr>> {
    let mut builder = LEntryBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &LEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LEntry::VT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<f64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct LEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f64,
}
impl<'a> Default for LEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    LEntryArgs {
      key: None, // required field
      value: 0.0,
    }
  }
}

pub struct LEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(LEntry::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
}  // pub mod CustomMap_
}  // pub mod mypackage

